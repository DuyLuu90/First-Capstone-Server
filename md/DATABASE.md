# KNEX METHODS:
    Search item:
        db('').select('').where('','ILIKE',`%${searchTerm}%`)
        db('').select('').whereNotNull('column')
    Paginating items:
        const offset= itemsPerPage*(page-1)
        db('').select('').limit(itemsPerPage).offset(offset)
    Sort items:
        (now()-'30 days'::INTERVAL)
        GROUP BY
        ORDER BY 'column' ASC, 'column' DESC;
    ADD ENUM type
        CREATE TYPE .TYPE.. AS ENUM ('..','..');
        ALTER TABLE ... ADD COLUMN ... style ...


# LEARNING A NEW CODEBASE:
    async vs await:
        async: contain 0 or more <await> expression
        await: suspend progress through an async function, yielding control and subsequently resuming progress only when an awaited promosied-based asynchronous opt is either fulfilled or rejected
    transaction():
        fundamental concept of all db system, bundles multiple steps into a single operation (all or nothing)
        take-away: complete or nothing, permanently recorded, invisible to other transaction.
        How does it relate to BEGIN and COMMIT in Postgres?
            BEGIN start the transaction
            COMMIT end the transaction
    sequence table:
        sequence: is a ordered list of integers. It is a special type of data, used to generate unique numeric identifiers. 
        Syntax:
            CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name
                [ AS { SMALLINT | INT | BIGINT } ]
                [ INCREMENT [ BY ] increment ]
                [ MINVALUE minvalue | NO MINVALUE ] 
                [ MAXVALUE maxvalue | NO MAXVALUE ]
                [ START [ WITH ] start ] 
                [ CACHE cache ] 
                [ [ NO ] CYCLE ]
                [ OWNED BY { table_name.column_name | NONE } ]
        sequence table: table objects created with CREATE SEQUENCE
        Syntax: 
            CREATE TABLE IF NOT EXIST <tableName> (
                <columnName> SERIAL PRIMARY KEY,
            )
        Link: https://www.postgresql.org/docs/9.5/sql-createsequence.html 
    SERIAL PRIMARY KEY:
        PRIMARY KEY: special column contain unique value
        SERIAL: 
            create a sequence obj->set the next value generated by the sequence as the default val
            ->add NOT NULL constrain to primary key column
        Syntax:
            CREATE TABLE <tableName> (<columnName> SERIAL);
    RESTART IDENTITY CASCADE
        RESTART IDENTITY: automatically restart sequences owned by columns of the truncated table
        CASCADE: automatically truncate all have foreign-key ref to any of the named table
        RESTRICT: refuse to truncate if any of the tables have foreign key references from tables not listed in the command
    SELECT setval('sequence_name',nextVal):
        Set the next value for the next sequence
        The result returned by SETVAL() is next_value or NULL if the given next_value and round is smaller than the current value.
        Link: https://www.postgresql.org/docs/8.2/functions-sequence.html 

# SUMMARY:   
    # TAKE NOTES:
        db.raw && DISTINCT && author:
        leftjoin()
        json-function: 
            Link: https://www.postgresql.org/docs/9.5/functions-json.html  
            json_strip_nulls: Returns from_json with all object fields that have null values omitted. Other null values are untouched.
            json_build_object: Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.
        jwt-decode:
            Link: https://www.npmjs.com/package/jwt-decode 
            small library that helps decoding JWTs token which are Base64Url encoded.
        Treeize()
            Converts row data (in JSON/associative array format or flat array format) to object/tree structure based on simple column naming conventions. (https://www.npmjs.com/package/treeize)
            .grow() 

    # PROJECT GENERAL IDEA:
        To list the dir:            tree -I node_modules -d
        To install tree:            brew install tree || sudo apt i tree
        To show avai commands:      npm run
    # FIGURE OUT HOW TO RUN THE PROJECT
        To create db:               CREATE DATABASE <dbName> OWNER <roleName>;
        To run migrate:             npm run migrate
        To seed db:                 psql -U <roleName> <dbName> -f <filePath>
                                    copy <dbName> FROM <filePath>
    # FIND THE INTERFACE OF THE PROJECT:
        Frontend:   through the browser, using buttons on the page,and routes in the address bar
        Backend:    through API endpoints
        Tests:
            Files:  xxx.test.js || xxx.spec.js
            Syntax: npm run migrate:test (run the migrations for the test database)
    # DISCUSSION:

# PROTECTED ENDPOINTS:
    ## NOTES:
        Protected endpoint is an endpoint which can only be used by authenticated req
        Encoded val is val that human wouldn't be able to read and understand w/o using a machine (!= decode)
        Basic auth involves Base64
        window.btoa() === ``
        window.localStorage.setItem('name', 'value') -> Check at application/storage/localStorage
    ## CLIENTS:
        Use headers along with fetch req:
            'authorization': `basic ${TokenService.getAuthToken}`
        App:
            PublicOnlyRoute vs PrivateRoute
    ## SERVERS:
        Middleware:
            function requireAuth(req,res,next) {
            const authToken = req.get(`Authorization`) || ''
            if (!authToken.toLowerCase().startWith('basic')){
                return res.status(401).json({error:`Missing basic token`});}
            next()}
        Router:
            .all(requireAutth)

# DATA PROTECTION:
    ## NOTES:
        #Good practices: Ask for consent, only store the data you need,use pseudonyms,use authentication mechanisms
        #Pseudonymised:  encryping PIN, masking info,hashing data
        #Hashing:
            Encrypt: secret code (can be converted)
            Hash: cannot be reverted, make it extremely difficult to guess
        #Bcrypt: A form of "hashing"
            Salt: random text added to the string to be hashed (10->12)
            bcrypt.compare(bcrypt.hash('text'),'text')    compare a string with the hash we generated
            bcrypt.hashSync()
    ## CLIENTS:
    ## SERVERS:
        Install bcryptjs-> Run bcrypt.hash('password',12).then(hash=>console.log({hash}))
        update db seeding data

# PROTECTED ENDPOINTS:
    ## NOTES:
    ## CLIENTS:
    ## SERVERS:
    





